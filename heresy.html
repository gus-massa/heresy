<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="generator" content="http://www.nongnu.org/elyxer/"/>
<meta name="create-date" content="2014-12-23"/>
<link rel="stylesheet" href="http://elyxer.nongnu.org/lyx.css" type="text/css" media="all"/>
<title>The Heresy Programming Language</title>
</head>
<body>
<div id="globalWrapper">
<h1 class="title">
The Heresy Programming Language
</h1>
<h2 class="author">
John S. Berry III
</h2>
<div class="abstract">
<p class="abstract-message">
Abstract
</p>
The Heresy language is a functional Lisp/Scheme dialect implemented in Racket, with syntax inspired by the BASIC family of programming languages. It’s principle goals are to provide a simple core language for BASIC and other programmers to experiment with and learn how to program functionally. This document will detail the general philosophy of the Heresy language, such as exists, as well as the language syntax and functions. <br/>
The Heresy language was created by John S. Berry III with additional contributions from many others in the Racket community. <br/>
Heresy and this documentation are Copyright (c) 2014 John S. Berry III and released under the terms of the GNU LGPL.
</div>
<h1 class="Section">
<a class="toc" name="toc-Section-1">1</a> The Heresy Rules
</h1>
<div class="Unindented">
The Heresy language is developed according to a few basic "ground rules," which the author and contributors attempt to follow in developing new features and functions for the language. These are as follows:
</div>
<ol>
<li>
<b>Heresy is BASIC</b> - Heresy is inspired by BASIC, and aims to be at least somewhat easy for BASIC programmers to learn. Mostly this means we prefer BASIC names for functions over the Lisp name, and naming conventions like the $ for string functions.
</li>
<li>
<b>Heresy is a Lisp</b> - Heresy is still a Lisp, and loves simple syntax and s-expressions. While it makes use of some sugaring like literal keywords for certain common primitives, these are best used sparingly. Heresy is the Diet Coke of Evil, just one calorie, not quite evil enough.
</li>
<li>
<b>Heresy is functional </b>- Functional, but not Haskell. It is not intended solely as a vehicle for absolute functional purity. I love Haskell. You love Haskell. We don’t need to write another Haskell. Think more in terms of a lower-calorie, more intelligible Clojure.
</li>
<li>
<b>Heresy is for learning</b> - Heresy started as a learning project, a chance to learn how Lisp and functional programming really work on a practical level. I hope that, in time, it can be that for others as well, especially those who grew up with BASIC like myself and still sometimes struggle to get their head around the functional style. In particular, this means the Heresy-written portions of the source are generally written in as clear a manner as possible, as they are intended to be self-teaching.
</li>
<li>
<b>Heresy is an experiment</b> - Heresy is an experimental language. It’s very DNA is as a mad idea that came to life, and it’s development should be ready and willing to embrace new mad ideas and run with them. This is where carry came from, and I hope to have more mad ideas in the future.
</li>
<li>
<b>Heresy is for everyone</b> - As a statement of culture, the Heresy community welcomes the contribution of all people, who taste equally delicious to the jaws of mighty Cthulhu. No discrimination, harassment, or any other mistreatment of contributors on the basis of age, race, sexuality, or gender will <b>ever</b> be tolerated by myself or anyone else who wishes to be part of this project.
</li>

</ol>
<h1 class="Section">
<a class="toc" name="toc-Section-2">2</a> Heresy Syntax and Conventions
</h1>
<div class="Unindented">
Generally speaking, Heresy follows standard s-expression syntax as expected from any Lisp, being composed of parenthesized sequences of terms in Polish notation. Each sequence thus begins with an operator or function, and any number of arguments or additional s-expressions as needed.
</div>
<div class="Indented">
There are however a few exceptions to usual expectations in the case of certain special forms like for, def, and if. These make use of additional literal terms as part of their syntax, to provide more clarity and similarity to BASIC-style syntax.
</div>
<div class="Indented">
In accordance with that goal, Heresy also follows certain naming conventions as a matter of style. Functions which produce a string value are appended with $, and in general where a naming conflict between two similar functions in Racket/Scheme and BASIC exists, prefer BASIC.
</div>
<div class="Indented">
When borrowing BASIC syntax and naming for use in Heresy, the author has generally relied chiefly on QBASIC and ECMA BASIC for reference.
</div>
<h1 class="Section">
<a class="toc" name="toc-Section-3">3</a> Heresy Reference
</h1>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.1">3.1</a> Declarations
</h2>
<pre class="LyX-Code">
(def <i>name value</i>)
</pre>
<div class="Unindented">
Defines a new variable of <i>name</i> with the given <i>value.</i>
</div>
<pre class="LyX-Code">
(def<b> </b>fn <i>name </i>([<i>arg</i> ...]) <i>body</i> ...)
</pre>
<div class="Unindented">
Defines a function of <i>name</i>, which when called evaluates its body expressions with the given list of arguments bound to local variables for use in the body of the function’s definition. Note that there are a number of additional options here for defining arguments. Default values can be ascribed to an argument by enclosing it in additional parentheses:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">&gt; (define foo (x (y 1)) (+ x y))
&gt; (foo 3 4)
7
&gt; (foo 5)
6
</pre>
</div>

</div>
<div class="Indented">
Two patterns as well exist for taking an arbitrary number of values. The argument names list can be forgone entirely and substituted with a single name (generally<i> args*<tt></tt></i> by convention), which will then contain a list of any and all values passed to the function. The second method is the use of the dot (.) in the body of the arguments list followed by a single variable (usually called <i>rest</i>).
</div>
<pre class="LyX-Code">
(let ((<i>name value</i>) ...) <i>body</i> ...)
</pre>
<div class="Unindented">
Binds the given name-value pairs for use in the local context created by the body of the expression. This is used to define local variables, such as are needed within a function. Note that local functions can potentially be assigned this way by storing anonymous functions, but there is a built-in syntax for defining a single such function, like so:
</div>
<pre class="LyX-Code">
(let <i>proc</i> ((<i>name value) ...</i>) <i>body ...</i>)
</pre>
<div class="Unindented">
When <i>let</i> is called this way, it defines a local function <i>proc</i> (conventionally called <i>recur</i>), which can then be called from within the body of the <i>let</i> in order to perform local recursion; the name-value pairs thus act as arguments to the function <i>proc</i>. 
</div>
<pre class="LyX-Code">
(fn ([<i>arg ...</i>]) <i>body ...</i>)
</pre>
<div class="Unindented">
Creates an anonymous function with the given arguments, that evaluates its body when called. This is the <i>lambda</i> expression from other Lisps and functional languages, and a given <i>fn</i> can be passed as a value (as can named functions, for that matter) wherever called for. An anonymous function can also be evaluated directly in place by using it as the operator in an expression, like so:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">&gt; ((fn (x y) (* x y)) 4 5)
20
</pre>
</div>

</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.2">3.2</a> Conditionals and Loops
</h2>
<pre class="LyX-Code">
(if <i>test</i> then <i>texpr </i>else <i>fexpr</i>)
</pre>
<div class="Unindented">
Evalutes <i>test</i> and, if <i>test </i>is True, evaluates <i>texpr</i>, otherwise it evaluates <i>fexpr.</i> Note that only a single expression can be placed in each &ldquo;slot&rdquo; in the syntax; if you need to do multiple things, use a <i>do</i> block. 
</div>
<pre class="LyX-Code">
(select (<i>test1 expr1) ... </i>[(else <i>fexpr</i>)])
</pre>
<div class="Unindented">
Given a list of test-expression pairs, evaluates the tests in order until it finds one which is True, and evaluates the matching expression. The <i>else</i> expression is always true: if an else is found at the end of the <i>select</i> statement, its matching <i>fexpr</i> will be evaluated. If no test in <i>select</i> is true, returns <i>#&lt;void&gt;.</i>
</div>
<pre class="LyX-Code">
(select case <i>texpr </i>((<i>val ...</i>) <i>rexpr</i>) ... [(else <i>fexpr</i>)])
</pre>
<div class="Unindented">
Evaluates <i>texpr </i>and compares it to <i>vals</i> in turn until it finds a value that is <i>eq?</i> to the result of <i>texpr. </i>If one is found, it evaluates the matching <i>rexpr</i>. Like with <i>select</i>, <i>else</i> is always considered True, and will therefore always evaluate its <i>fexpr. </i>If no matching <i>val</i> is found, <i>select case</i> evaluates to <i>#&lt;void&gt;.</i> Not also that the <i>(val ...) </i>is a list, and can contain as many values as is needed, such as in the following example: 
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">&gt; (select case (* 2 3)
    ((2 3 4) (print "Nope."))
    ((5 6 7) (print "Yup."))
    (else (print "something is horribly wrong.")))
Yup.
</pre>
</div>

</div>
<pre class="LyX-Code">
(for (<i>var </i>in <i>list</i> [with <i>cry</i>]) <i>body ...</i>)
</pre>
<div class="Unindented">
Iterates over <i>list</i> evaluating it’s body with the <i>head</i> of <i>list </i>assigned to <i>var</i>, then recurs with the <i>tail</i> of <i>list</i> until it returns Null. <i>for </i>loops declare an implicit variable <i>cry </i>which can be passed a value with <i>carry. </i>They may also be interrupted with <i>break. </i>See below for more details.
</div>
<pre class="LyX-Code">
(do <i>body ...</i>)
</pre>
<div class="Unindented">
Evaluates its body in order, returning the result of the final body expression.
</div>
<pre class="LyX-Code">
(do loop [with <i>cry</i>] <i>body ...</i>)
</pre>
<div class="Unindented">
Evaluates <i>body</i> repeatedly until a <i>break</i> statement is encountered. Declares the implicit variable <i>cry, </i>which can be reassigned with the <i>carry </i>operator<i>.</i>
</div>
<pre class="LyX-Code">
(break [<i>value</i>])
</pre>
<div class="Unindented">
Breaks the continuation of a <i>for </i>or <i>do loop</i> evaluation. If provided a value, returns that value as the result of the loop.
</div>
<pre class="LyX-Code">
(carry <i>value</i>)
</pre>
<div class="Unindented">
When called in the body of a <i>for </i>or <i>do loop</i> expression, immediately begins the next iteration of the loop, and passes the given value to the implicit variable <i>cry</i>.
</div>
<pre class="LyX-Code">
cry
</pre>
<div class="Unindented">
Loops declare an internal variable called <i>cry, </i>which defaults to Null, and which is passed automatically to the next iteration of the loop, and is returned when the loop concludes. The value of <i>cry</i> can be specified at the beginning of the loop with the optional <i>with </i>parameter, and <i>carry </i>can be used to pass a new value of <i>cry </i>to the next iteration.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.3">3.3</a> Predicates and Logic
</h2>
<pre class="LyX-Code">
(list? <i>v</i>)
</pre>
<div class="Unindented">
Returns True if <i>v</i> is a list.
</div>
<pre class="LyX-Code">
(null? <i>v</i>)
</pre>
<div class="Unindented">
Returns True if <i>v</i> is Null, where Null is defined as the empty list <tt>’()</tt>.
</div>
<pre class="LyX-Code">
(zero? <i>v</i>)
</pre>
<div class="Unindented">
Returns True if <i>v</i> = 0.
</div>
<pre class="LyX-Code">
(one? <i>v</i>)
</pre>
<div class="Unindented">
Returns True if <i>v = 1.</i>
</div>
<pre class="LyX-Code">
(eq? <i>x y</i>)
</pre>
<div class="Unindented">
Returns True if <i>x </i>and <i>y</i> are the same object.
</div>
<pre class="LyX-Code">
(equal? <i>x y</i>)
</pre>
<div class="Unindented">
Returns True if <i>x</i> and <i>y</i> are equal.
</div>
<pre class="LyX-Code">
(symbol? <i>v</i>)
</pre>
<div class="Unindented">
Returns True if <i>v</i> is a symbol: ie. a quoted name such as <i>’foo.</i> See <i>quote</i> in 3.4.
</div>
<pre class="LyX-Code">
(atom? <i>v</i>)
</pre>
<div class="Unindented">
Returns True if <i>v</i> is an atom: ie. a number, symbol, or procedure, rather than another list or Null.
</div>
<pre class="LyX-Code">
(lat? <i>l</i>)
</pre>
<div class="Unindented">
Returns True if <i>l</i> is a list composed solely of atoms.
</div>
<pre class="LyX-Code">
(and <i>expr ...</i>)
</pre>
<div class="Unindented">
Returns True only if all given expressions are True. 
</div>
<pre class="LyX-Code">
(or <i>expr</i> ...)
</pre>
<div class="Unindented">
Returns True if any given expression is True. 
</div>
<pre class="LyX-Code">
(not <i>v</i>)
</pre>
<div class="Unindented">
Returns True if <i>v</i> is False, else returns False.
</div>
<pre class="LyX-Code">
else 
</pre>
<div class="Unindented">
A special keyword for True, used as a literal in conditional statements.
</div>
<pre class="LyX-Code">
True 
</pre>
<div class="Unindented">
The boolean truth value. Actually an alias for #t in the Racket implementation. Note that, in Heresy, as in Racket, anything not explicitly False is considered True.
</div>
<pre class="LyX-Code">
False
</pre>
<div class="Unindented">
The boolean false value. Actually an alias for #f in the Racket implementation.
</div>
<pre class="LyX-Code">
Null
</pre>
<div class="Unindented">
An alias for the empty list<tt> ’()</tt>.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.4">3.4</a> Syntax and Evaluation
</h2>
<pre class="LyX-Code">
(quote <i>v</i>)
’<i>v</i>
</pre>
<div class="Unindented">
&ldquo;Quotes&rdquo; the given <i>v, </i>without evaluating it’s contents. A quoted list is passed merely as data, a quoted atom is a &ldquo;symbol&rdquo; as per <i>symbol?. </i>Can be shortened to <tt>’</tt>. 
</div>
<pre class="LyX-Code">
(quasiquote <i>v</i>)
‘<i>v</i>
</pre>
<div class="Unindented">
Same as <i>quote,</i> but can be &ldquo;escaped&rdquo; with the <i>unquote</i> and <i>unquote-splicing</i> syntax. Can be shortened to <tt>‘</tt>.
</div>
<pre class="LyX-Code">
(unquote <i>v</i>)
,<i>v</i>
</pre>
<div class="Unindented">
When encountered within a a quasiquoted block, evaluates <i>v </i>and quotes its value instead. Can be shortened to <tt>,</tt>.
</div>
<pre class="LyX-Code">
(unquote-splicing <i>v</i>)
,@<i>v</i>
</pre>
<div class="Unindented">
Similar to <i>unquote,</i> but splices the result of evaluating <i>v</i> in place. Can be shortened to <tt>,@</tt>.
</div>
<pre class="LyX-Code">
(error [<i>symbol</i>] <i>message</i>)
</pre>
<div class="Unindented">
Halts the program, returning an error of <i>symbol: message</i> where <i>symbol </i>is a quoted value (customarily the name of the current function) and <i>message </i>is a string. 
</div>
<pre class="LyX-Code">
(run <i>form</i>)
</pre>
<div class="Unindented">
Evaluates the given form. Usage is not recommended.
</div>
<pre class="LyX-Code">
(rem <i>any ...</i>)
</pre>
<div class="Unindented">
Ignores its arguments and returns void. Useful for block comments. 
</div>
<pre class="LyX-Code">
(def macro <i>name </i>([<i>pattern ...</i>]) <i>template ...</i>)
</pre>
<div class="Unindented">
Defines a new macro with <i>name</i>. A macro can best be thought of as a function which is not evaluated, but rather returns syntax to be evaluated in the form of a template. Each name described in the <i>pattern</i> defines a &ldquo;pattern variable&rdquo; which can then be used in the body of the <i>template</i> and will pass any syntax contained in that portion of the <i>pattern </i>in the appropriate location matched in the <i>template.</i> The elipsis ... can be used in a pattern to indicate repeatable values.
</div>
<pre class="LyX-Code">
(apply <i>fun v ... lst</i>)
</pre>
<div class="Unindented">
Applies <i>fun</i> to the given arguments, as if it had been called with <tt>(fun v ... lst)</tt>.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.5">3.5</a> Input and Output
</h2>
<pre class="LyX-Code">
(print [&amp;|lit] [<i>v</i>])
</pre>
<div class="Unindented">
Prints the given <i>v</i> to the current output, or stdout if not otherwise specified, followed by a newline. <i>(print &amp; v)</i> outputs without a newline, while <i>(print lit v)</i> outputs as a literal form that can be directly read back by <i>(input stx ...)</i> as code. A bare <i>(print)</i> merely prints a newline to the current output. 
</div>
<pre class="LyX-Code">
(? ...)
</pre>
<div class="Unindented">
A shortened macro for <i>print.</i>
</div>
<pre class="LyX-Code">
(input [stx] [<i>string</i>])
</pre>
<div class="Unindented">
Reads a line of input from the current input, or stdin if not otherwise specified, and returns the value read as a string. <i>(input stx ...)</i> instead reads a value using the standard reader, thus providing syntax which can be evaluated with <i>run</i>. If additionally provided with a <i>string,</i> this will be output as a prompt to the current output.
</div>
<pre class="LyX-Code">
(using <i>io-port body ...</i>)
</pre>
<div class="Unindented">
Evaluates the body, with input/ouptut redirected to the given <i>io-port. </i>Only the <i>file</i> port is supported at this time.
</div>
<pre class="LyX-Code">
(file <i>name</i> as <i>mode</i>)
</pre>
<div class="Unindented">
Opens the file <i>name </i>as the new target for input or output, depending on the <i>mode</i> provided<i>.</i> <i>mode </i>is a symbol, of one of the following:
</div>
<div class="Labeling">
<tt>’output</tt> Opens file as the current output port. Will fail if file already exists.
</div>
<div class="Labeling">
<tt>’rewrite</tt> Opens file as the current output port, rewriting its contents if the file exists.
</div>
<div class="Labeling">
<tt>’input</tt> Opens file as the current input port. 
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.6">3.6</a> Lists
</h2>
<pre class="LyX-Code">
(list <i>v ...</i>)
</pre>
<div class="Unindented">
Returns a list containing the given values.
</div>
<pre class="LyX-Code">
(join <i>a b</i>)
</pre>
<div class="Unindented">
Joins <i>a </i>and <i>b</i> into a pair. If <i>b</i> is Null, a list is created containing <i>a</i>. If <i>b</i> is a list, <i>a </i>is joined to the head of the list. 
</div>
<pre class="LyX-Code">
(head <i>l</i>)
</pre>
<div class="Unindented">
Returns the head (first element) of the list <i>l</i>. 
</div>
<pre class="LyX-Code">
(tail <i>l</i>)
</pre>
<div class="Unindented">
Returns the remainder of list <i>l</i> after the <i>head.</i> If the list has only one element, returns Null.
</div>
<pre class="LyX-Code">
(map <i>fun l</i>)
</pre>
<div class="Unindented">
Given a single-argument function <i>fun, </i>returns a list with <i>fun </i>applied to each item in <i>l.</i>
</div>
<pre class="LyX-Code">
(filter <i>fun</i> <i>l</i>)
</pre>
<div class="Unindented">
Given a predicate <i>fun</i>, returns a new list containing only those elements of <i>l </i>for which <i>fun</i> returns True.
</div>
<pre class="LyX-Code">
(len <i>l</i>)
</pre>
<div class="Unindented">
Returns the number of items in <i>l.</i>
</div>
<pre class="LyX-Code">
(foldr <i>fun base l</i>)
</pre>
<div class="Unindented">
Given a function <i>fun</i> with two arguments, returns the cumulative result of <i>fun </i>being applied to consecutive pairs, starting from <i>base</i> and the rightmost element of <i>l.</i>
</div>
<pre class="LyX-Code">
(foldl <i>fun base l</i>)
</pre>
<div class="Unindented">
Similar to <i>foldr, </i>except that it combines pairs from the left, starting with the head of <i>l </i>and <i>base.</i>
</div>
<pre class="LyX-Code">
(reverse <i>l</i>)
</pre>
<div class="Unindented">
Returns a list with the order of <i>l </i>reversed.
</div>
<pre class="LyX-Code">
(index <i>n l</i>)
</pre>
<div class="Unindented">
Returns the <i>n</i>th entry of <i>l, </i>indexed from 1.
</div>
<pre class="LyX-Code">
(index* <i>l dims ...</i>)
</pre>
<div class="Unindented">
Walks through nested lists according to the given <i>dims</i>, essentially finding <i>index</i> recursively for an arbitrary number of dimensions. For example, given a nested list three lists deep, <i>(index* l 2 3 1) </i>would return the 1st element of the third element of the 2nd lst, like so:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">&gt; (def dave ’(1 (2 3 (4 5)) 6))
&gt; (index* dave 2 3 1)
4
</pre>
</div>

</div>
<pre class="LyX-Code">
(inlst <i>item</i> <i>l</i>)
</pre>
<div class="Unindented">
Searches <i>l</i> for <i>item</i>, returning the index of <i>item</i> if found, or False if not.
</div>
<pre class="LyX-Code">
(left <i>l n</i>)
</pre>
<div class="Unindented">
Returns a list of the leftmost <i>n</i> elements of <i>l.</i>
</div>
<pre class="LyX-Code">
(right <i>l n)</i>
</pre>
<div class="Unindented">
Returns a list of the rightmost <i>n </i>elements of <i>l.</i>
</div>
<pre class="LyX-Code">
(mid <i>l idx n</i>)
</pre>
<div class="Unindented">
Returns <i>n </i>entries of <i>l</i> starting from index <i>idx</i>.
</div>
<pre class="LyX-Code">
(slice <i>l first</i> [<i>last</i>])
</pre>
<div class="Unindented">
Returns a slice of <i>l</i>, starting at <i>first</i> and ending at <i>last</i>. If <i>last</i> is not provided, it defaults to the end of the list.
</div>
<pre class="LyX-Code">
(append1 <i>l1 l2</i>)
</pre>
<div class="Unindented">
Returns a list with <i>l2 </i>appended to the end of <i>l1.</i>
</div>
<pre class="LyX-Code">
(append <i>l</i> ...)
</pre>
<div class="Unindented">
Returns a list of the given <i>l</i>s appended together in order. 
</div>
<pre class="LyX-Code">
(assoc <i>tgt l</i>)
</pre>
<div class="Unindented">
Searches the heads of a list of lists <i>l</i> and returns the first matching list or False.
</div>
<pre class="LyX-Code">
(subst <i>tgt new l</i>)
</pre>
<div class="Unindented">
Searches the heads of a list of lists <i>l, </i>and if it finds <i>tgt</i>, returns a new list with the tail of <i>tgt</i> substituted for <i>new</i>. Otherwise, returns False.
</div>
<pre class="LyX-Code">
(heads <i>l</i>)
</pre>
<div class="Unindented">
Returns a list of the heads of a list of lists. 
</div>
<pre class="LyX-Code">
(sort <i>fun l</i>)
</pre>
<div class="Unindented">
Sorts list <i>l </i>according to the comparison function <i>fun</i>.
</div>
<pre class="LyX-Code">
(zip <i>l1 l2</i>)
</pre>
<div class="Unindented">
Returns a new list of lists combining <i>l1 </i>and <i>l2. </i>Excess length of either list is dropped.
</div>
<pre class="LyX-Code">
(zipwith <i>fun l1 l2</i>)
</pre>
<div class="Unindented">
Returns a new list, combining the matching pairs of each list with <i>fun. </i>Excess length of either list is dropped.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.7">3.7</a> Strings
</h2>
<pre class="LyX-Code">
(=$ <i>x y</i>)
</pre>
<div class="Unindented">
Returns True if the two strings are equal.
</div>
<pre class="LyX-Code">
(&amp; <i>str ...</i>)
</pre>
<div class="Unindented">
Concatenates its arguments into a single string.
</div>
<pre class="LyX-Code">
(list$ <i>str</i>)
</pre>
<div class="Unindented">
Returns a list of one-character strings from the given string.
</div>
<pre class="LyX-Code">
(str$ <i>n</i>)
</pre>
<div class="Unindented">
Converts a number <i>n</i> to a string.
</div>
<pre class="LyX-Code">
(empty$? <i>str</i>)
</pre>
<div class="Unindented">
Returns True if the string is empty (<tt>&ldquo;&rdquo;</tt>).
</div>
<pre class="LyX-Code">
(len$ <i>str</i>)
</pre>
<div class="Unindented">
Returns the length of the string, indexed from 1.
</div>
<pre class="LyX-Code">
(list&amp; <i>l</i>)
</pre>
<div class="Unindented">
Given a list of strings, returns a single concatenated string.
</div>
<pre class="LyX-Code">
(head$ <i>str</i>)
</pre>
<div class="Unindented">
Returns the head (first character) of the string.
</div>
<pre class="LyX-Code">
(tail$ <i>str</i>)
</pre>
<div class="Unindented">
Returns the tail (remaining characters) of the string, unless <i>str</i> is empty, in which case it returns the empty string.
</div>
<pre class="LyX-Code">
(left$ <i>str</i> <i>n</i>)
</pre>
<div class="Unindented">
Returns a string of the leftmost <i>n</i> characters of <i>str.</i>
</div>
<pre class="LyX-Code">
(right$ <i>str n</i>)
</pre>
<div class="Unindented">
Returns a string of the rightmost <i>n </i>characters of <i>str.</i>
</div>
<pre class="LyX-Code">
(mid$ <i>str idx len</i>)
</pre>
<div class="Unindented">
Returns a section of <i>str, len </i>characters long, beginning at <i>idx.</i>
</div>
<pre class="LyX-Code">
(slice$ <i>str start </i>[<i>finish</i>])
</pre>
<div class="Unindented">
Returns a slice of <i>str </i>beginning at <i>start</i> and ending at <i>finish</i>. If not specified, <i>finish</i> defaults to the length of the string. 
</div>
<pre class="LyX-Code">
(instr <i>str</i> <i>search</i>)
</pre>
<div class="Unindented">
Returns the index of the first instance of <i>search</i> in <i>str</i>, or False if not found.
</div>
<pre class="LyX-Code">
(split <i>str </i>[<i>delimiters</i>])
</pre>
<div class="Unindented">
Returns a list of string sections split at the given delimiters. If <i>delimiters </i>is not specified, defaults to space (<tt>&ldquo; &ldquo;</tt>).
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.8">3.8</a> Math
</h2>
<pre class="LyX-Code">
(+ [<i>x y ...</i>])
</pre>
<div class="Unindented">
Adds the given numbers left to right and returns the result. If only one argument is given, returns the argument. If no arguments are provided, returns 0.
</div>
<pre class="LyX-Code">
(- <i>x </i>[<i>y ...</i>]) 
</pre>
<div class="Unindented">
Subtracts the given numbers left to right and returns the result. If only one argument is given, returns <i>(- 0 x). </i>
</div>
<pre class="LyX-Code">
(/ <i>x </i>[<i>y ...</i>])
</pre>
<div class="Unindented">
Divides the numbers from left to right and returns the result. If only one argument is given, returns <i>(/ 1 x)</i>. 
</div>
<pre class="LyX-Code">
(* [<i>x y ...</i>])
</pre>
<div class="Unindented">
Multiplies the numbers given from left to right and returns the result. If no argument is given, returns one. If one argument is given, returns the argument. 
</div>
<pre class="LyX-Code">
(= <i>x y ...</i>)
</pre>
<div class="Unindented">
Returns True if all the numbers are numerically equal.
</div>
<pre class="LyX-Code">
(&lt; <i>x y ...</i>)
</pre>
<div class="Unindented">
Returns True if all arguments are greater than the one previous going right (ie, <i>x &lt; y &lt; z, etc.</i>)
</div>
<pre class="LyX-Code">
(&gt; <i>x y ...</i>)
</pre>
<div class="Unindented">
Returns True if all arguments are less than the one previous going right (ie, <i>x &gt; y &gt; z, etc.</i>)
</div>
<pre class="LyX-Code">
pi
</pre>
<div class="Unindented">
A bound variable containing the 64-bit floating point value of pi.
</div>
<pre class="LyX-Code">
e
</pre>
<div class="Unindented">
A bound variable containing the 64-bit floating point value of Euler’s number. 
</div>
<pre class="LyX-Code">
(mod <i>x y</i>)
</pre>
<div class="Unindented">
Returns the modulus of <i>x</i> divided by <i>y</i>.
</div>
<pre class="LyX-Code">
(abs <i>n</i>)
</pre>
<div class="Unindented">
Returns the absolute value of <i>n.</i>
</div>
<pre class="LyX-Code">
(even? <i>n</i>) 
</pre>
<div class="Unindented">
Returns True if <i>n</i> is even.
</div>
<pre class="LyX-Code">
(odd?<i> n</i>) 
</pre>
<div class="Unindented">
Returns True if <i>n</i> is odd.
</div>
<pre class="LyX-Code">
(sgn <i>n</i>)
</pre>
<div class="Unindented">
Returns -1 if <i>n </i>is negative, 0 if <i>n</i> is zero, and 1 if <i>n</i> is positive.
</div>
<pre class="LyX-Code">
(inc <i>n</i>)
</pre>
<div class="Unindented">
Returns the value of <i>(+ n 1).</i>
</div>
<pre class="LyX-Code">
(dec <i>n</i>)
</pre>
<div class="Unindented">
Returns the value of <i>(- n 1)</i>.
</div>
<pre class="LyX-Code">
(exp <i>x</i>)
</pre>
<div class="Unindented">
Returns the value of <i>e<sup>x</sup>.</i>
</div>
<pre class="LyX-Code">
(sin <i>x</i>)
</pre>
<div class="Unindented">
Returns the sine of <i>x</i> as a floating point value.
</div>
<pre class="LyX-Code">
(cos <i>x</i>)
</pre>
<div class="Unindented">
Returns the cosine of <i>x</i> as a floating point value.
</div>
<pre class="LyX-Code">
(tan<i> x</i>)
</pre>
<div class="Unindented">
Returns the tangent of <i>x</i> as a floating point value.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.9">3.9</a> Things
</h2>
<div class="Unindented">
Things are Heresy’s definable data structures. Unlike the objects of most object-oriented languages, which often exist to hold and carry mutable state and actions with which to change that state, Things are immutable. A Thing, once sprung to life, cannot itself be altered, but can be called with the correct syntax to return a new Thing with different internal values for its internal data fields.
</div>
<div class="Indented">
Things are essentially functions, lambdas specifically, with predefined syntax arguments. They are first class values, and can be passed freely just as any other data, but can also be passed arguments to either return the values of their fields, return a new Thing, or to employ any functions contained within the thing. 
</div>
<pre class="LyX-Code">
(describe <i>Name </i>(<i>field value</i>) ...)
</pre>
<div class="Unindented">
Defines a new type of Thing, given <i>Name</i>. By convention, Things are generally named in uppercase, though this is not required by the syntax. Each <i>field</i> is an internal name and external symbol, which is mapped to the given <i>value. </i>Anonymous functions (<i>fn</i>) can be assigned as values to Thing fields, and those functions can access the fields of the Thing by name.
</div>
<pre class="LyX-Code">
({Name} [<i>’symbol</i>|’fields|<i>pattern</i>])
</pre>
<div class="Unindented">
Once a Thing has been described or bound to a name by other means, that <i>Name </i>is bound locally as a function, and can thus be called with special syntax to return its contents or to return a new copied Thing. In more detail, these syntaxes are as follows:
</div>
<pre class="LyX-Code">
(Name)
</pre>
<div class="Unindented">
Returns an association list containing the contents of the Thing, ie. a list in the form of: <i>’((field value) ...)</i>
</div>
<pre class="LyX-Code">
(Name ’fields)
</pre>
<div class="Unindented">
Returns a list of symbols for the fields contained within the Thing. Note that the symbol <i>’fields</i> takes precedent over the field names within, in order to prevent overwriting this syntax. 
</div>
<pre class="LyX-Code">
(Name <i>’symbol</i>)
</pre>
<div class="Unindented">
Returns the value of the field associated with <i>’symbol,</i> the quoted form of the field name described when the Thing type was first declared. Will return an error if no such named field is found. If the value associated with symbol is a function, this expression can be used as the operating function of a further expression like so:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">&gt; (describe Lord-Cthulhu (eat (fn (x) (print (&amp; "Devours " x)))))
&gt; ((Lord-Cthulhu ’eat) "Dave")
Devours Dave
</pre>
</div>

</div>
<pre class="LyX-Code">
(Name <i>pattern</i>)
pattern = ’([*|<i>value</i>] ...)
</pre>
<div class="Unindented">
Returns a copy of the Thing, with new values according to the <i>pattern</i> passed to the original Thing. <i>Pattern</i> must be a quoted list of either *’s or values, in order according to the fields of the Thing as originally defined (so the first *|value matches the first field, the second to the second field, and so on). A * in a field indicates that the value is copied in-tact, while a <i>value</i> becomes the new value of the field in that position. For example:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">&gt; (describe Santa (size ’fat)
				  (sleigh ’ready)
				  (sack ’full))
&gt; (describe Santa-after-Christmas (Santa ’(* * ’empty)))
&gt; (Santa-after-Christmas)
((size ’fat) (sleigh ’ready) (sack ’empty))
</pre>
</div>

</div>
<pre class="LyX-Code">
(send <i>Thing ’symbol args ...</i>)
</pre>
<div class="Unindented">
An alternate syntax for accessing functions within Things, <i>send </i>calls the function named by <i>(Thing ’symbol)</i> with the given arguments and returns the result. 
</div>
<pre class="LyX-Code">
(Self ...)
</pre>
<div class="Unindented">
<i>Self </i>is the self-referring identifier for a Thing, allowing for functions within Things to call the Thing itself. Note that if it is only the values of the other fields, this is not necessary, as fields are defined as local names within the context of the Thing, and thus can be referred to simply by name.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.10">3.10</a> Theory
</h2>
<pre class="LyX-Code">
(Y <i>fn</i>)
</pre>
<div class="Unindented">
The strict Y fixed-point combinator. Allows for recursion of anonymous functions. Given a <i>fn1 </i>which contains a single named argument, and within which is an additional single-argument <i>fn</i>2, the innermost <i>fn2</i> can call the named argument of <i>fn1</i> as if it were a function name in order to recur on itself. For example, the factorial function can be defined thusly, using the Y-combinator:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">(define Fact   
  (Y     
    (fn (fact)       
      (fn (n)         
		(if (zero? n)            
			then 1             
			else (* n (fact (- n 1))))))))
</pre>
</div>

</div>
<div class="Indented">
Note however that usage of the Y-combinator for recursion is not especially efficient, and the more traditional recursive approach is generally recommended whenever possible (which is most of the time).
</div>
<pre class="LyX-Code">
(partial <i>fun args ...</i>)
</pre>
<div class="Unindented">
Returns a function with <i>args</i> partially applied to <i>fun, </i>which can then be passed the remaining arguments, as many as needed to complete the calculation. For example:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">&gt; (map (partial + 2) (range 1 to 4))
(3 4 5 6)
</pre>
</div>

</div>
<pre class="LyX-Code">
(compose <i>fn1 fn2</i>)
</pre>
<div class="Unindented">
Returns a new function which is a composition of <i>fn1 </i>and <i>fn2. </i>This function evaluates <i>fn2 </i>with its arguments<i>, </i>and then applies <i>fn1</i> to the result of <i>fn2.</i>
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">&gt; (define abs-sub (compose abs -))
&gt; (abs-sub 4 5)
1
</pre>
</div>

</div>

<hr class="footer"/>
<div class="footer" id="generated-by">
Document generated by <a href="http://elyxer.nongnu.org/">eLyXer 1.2.5 (2013-03-10)</a> on <span class="create-date">2014-12-23T16:12:28.664000</span>
</div>
</div>
</body>
</html>
